/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.corda.cpi.read.impl.file

import com.typesafe.config.Config
import com.typesafe.config.ConfigFactory
import net.corda.cpi.read.CPIListener
import net.corda.cpi.read.CPIMetadataListener
import net.corda.cpi.read.CPIRead
import net.corda.packaging.Cpb
import net.corda.packaging.internal.CpbLoader
import net.corda.v5.base.util.contextLogger
import org.slf4j.Logger
import java.io.File
import java.io.InputStream
import java.lang.IllegalArgumentException
import java.lang.IllegalStateException
import java.nio.file.FileSystems
import java.nio.file.FileVisitResult
import java.nio.file.Path
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.SimpleFileVisitor
import java.nio.file.attribute.BasicFileAttributes
import java.util.*

class CPIReadImplFile(private val nodeConfig: Config = ConfigFactory.empty()): CPIFileListener, CPIRead {
    private val cpis = Collections.synchronizedMap(mutableMapOf<Path, Cpb>())
    private val cpiListeners: MutableList<CPIListener> = Collections.synchronizedList(mutableListOf())
    private lateinit var watcher: CPIWatcher

    @Volatile
    private var snapshotSent = false
    @Volatile
    private var stopped = true

    private lateinit var startDir: Path

    companion object {
        val logger: Logger = contextLogger()
    }

    private fun populateSnapshot(startDir: Path) {
        val paths = mutableSetOf<Path>()
        val fileFinder = FileFinder("*.{cpi,cpb}", paths)
        Files.walkFileTree(startDir, fileFinder)
        paths.forEach {
            cpis[it] = loadCPI(it)
        }
    }

    override fun start() {

        startDir = Paths.get(nodeConfig.getString("CPIDirectory"))

        if (stopped) {
            stopped = false
            watcher = CPIWatcher(this)
            watcher.startWatching(startDir)
            populateSnapshot(startDir)
            updateListeners(cpis.map {it.value.identifier}.toSet())
            snapshotSent = true
        }
    }

    override fun stop() {
        if (!stopped) {
            stopped = true
            watcher.stopWatching()
        }
    }

    private fun updateListeners(changedKeys: Set<Cpb.Identifier>) {
        cpiListeners.forEach {
            it.onUpdate(changedKeys, cpis.map { el -> el.value.identifier to el.value.metadata }.toMap())
        }
    }

    override fun getCPI(cpbIdentifier: Cpb.Identifier): InputStream {
        val paths = cpis.filter { it.value.identifier == cpbIdentifier }.keys
        if (paths.size == 0) {
            throw IllegalArgumentException("Unknown cpbIdentifier")
        }
        if (paths.size > 1) {
            throw IllegalStateException("More than one CPI identifier found")
        }
        return Files.newInputStream(paths.first())
    }

    override fun registerCallback(cpiListener: CPIListener): AutoCloseable {
        cpiListeners.add(cpiListener)
        if (snapshotSent) {
            // TODO: Fix definition of key and identifier. Below it.key is a path
            val keys = cpis.map {it.value.identifier}.toSet()
            val identities = cpis.map { it.value.identifier to it.value.metadata }.toMap()
            cpiListener.onUpdate(keys, identities)
        }
        return CPIListenerRegistration(this, cpiListener)

    }

    override val isRunning: Boolean
        get() = !stopped

    override fun newCPI(cpiPath: Path) {
        val cpi = loadCPI(cpiPath)
        cpis[cpiPath] = cpi
        updateListeners(setOf(cpi.identifier))
    }

    override fun modifiedCPI(cpiPath: Path) {
        val cpi = loadCPI(cpiPath)
        cpis[cpiPath] = cpi
        updateListeners(setOf(cpi.identifier))
    }

    override fun deletedCPI(cpiPath: Path) {
        val cpi = cpis[cpiPath]
        if (cpi == null) {
            val errorStr = "Trying to delete an unknown CPI - path: $cpiPath"
            logger.error(errorStr)
            throw IllegalArgumentException(errorStr)
        }
        cpis.remove(cpiPath)
        updateListeners(setOf(cpi.identifier))
    }

    private fun loadCPI(cpiPath: Path): Cpb {
        return CpbLoader.from(File(cpiPath.toString()).inputStream(), cpiPath.parent, cpiPath.parent.toString(), true)
    }

    private fun unregisterCPIListCallback(cpiListener: CPIListener) {
        cpiListeners.remove(cpiListener)
    }

    class CPIListenerRegistration(private val readImplFile: CPIReadImplFile, private val cpiListener: CPIListener): AutoCloseable {
        override fun close() {
            readImplFile.unregisterCPIListCallback(cpiListener)
        }
    }
}

private class FileFinder(pattern: String, private val files: MutableSet<Path>): SimpleFileVisitor<Path>() {
    private val matcher = FileSystems.getDefault().getPathMatcher("glob:$pattern")

    override fun visitFile(file: Path?, attrs: BasicFileAttributes?): FileVisitResult {
        if (file != null && matcher.matches(file.fileName)) {
            files.add(file)
        }
        return FileVisitResult.CONTINUE
    }
}



